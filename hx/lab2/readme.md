复制lab1里改动的文件到lab2，都有哪些改了？
kern  --debug --kdebug.c
      --trap  --trap.c
      --init  --init.c  哦challenge没做那没事了

分配的任务是练习2

## 实验执行流程：
1. bootloader --比起lab1增加了物理内存资源的探测，似乎和练习2无关
2. 调用kern_entry --为kern_init设置堆栈，建立临时段映射（看3.5小节）
3. 调用kern_init
4. 调用pmm_init(这段是lab2)
5. pic_init,idt_init
## pmm_init:
1. 初始化物理内存页管理器框架pmm_manager；
2. 建立空闲的page链表，这样就可以分配以页（4KB）为单位的空闲内存了；
3. 检查物理内存页分配算法；
4. 为确保切换到分页机制后，代码能够正常执行，先建立一个临时二级页表；
5. 建立一一映射关系的二级页表；
6. 使能分页机制；
7. 从新设置全局段描述符表；
8. 取消临时二级页表；
9. 检查页表建立是否正确；
10. 通过自映射机制完成页表的打印输出（这部分是扩展知识）

ucore的内存管理经常需要查找页表：给定一个虚拟地址，找出这个虚拟地址在二级页表中对应的项。通过更改此项的值可以方便地将虚拟地址映射到另外的页上。可完成此功能的这个函数是get_pte函数。它的原型为
> pte_t *get_pte(pde_t *pgdir, uintptr_t la, bool create)

这个函数是返回了一个页表项的地址，输入参数pgdir是一级页表的起始位置，la是虚拟地址，create是控制是否新建页。
编程思路：
1. pgdir+la前10位得到二级页表的地址
2. 二级页表地址+la中10位得到页表项地址
3. 如果这里有页表项就直接返回，没有就分配，然后返回
4. 分配成功时，要给page的引用置1，说明有一个引用了，不然会出错
5. 分配失败就返回null

问题：
1. 理解错了，这个函数就是查二级页表有没有的，没有给分配，二级页表本身内容不用管，有二级页表起始地址就行了
编程思路改：
1. pgdir+la前10位得到一级页表的页表项
2. 看这个一级页表的页表项存在位，如果存在，就返回前20位+la中10位
3. 不存在，就看create
4. 分配成功时，要给page的引用置1，说明有一个引用了，不然会出错
5. 分配失败就返回null

还有问题：
1. 调这个函数的时候已经启动页机制了，直接取地址不对。。这个好坑
2. 分配出去的页要给置0

吐槽：
1. vscode报错报的人很烦，还不能直接转到定义，查个函数和宏定义麻烦死了
2. gdb单步调试一点也不好用，查不出地址的错


## 练习2问题解析：
* 页目录项（PDE）的每个组成部分的含义如下：
  * 前20位表示4K对齐的该PDE对应的页表起始位置（物理地址，该物理地址的高20位即PDE中的高20位，低12位为0）；
  * 第8-11位忽略，未被CPU使用，可保留给OS使用；
  * 第7位如果CR4.PSE位为1(是否可以扩展页容量)，这位一定是0，表示4KB，否则忽略；
  * 第6位也忽略；
  * 第5位用于表示该页是否被使用过；
  * 第4位(Page-level cache disable)设置为1则表示不对该页进行缓存；
  * 第3位(Page-level write-through)设置是否使用write through缓存写策略；
  * 第2位表示该页的访问需要的特权级；
  * 第1位表示是否允许读写；
  * 第0位为该PDE的存在位；

* 页表项（PTE）的每个组成部分的含义如下：
  * 高20位与PDE相似的，用于表示该PTE指向的物理页的物理地址；
  * 9-11位保留给OS使用；
  * 第8位如果CR4.PGE位为1(开启全局页)，这位决定是否是全局页；
  * 第7位页表属性位
  * 第6位表示该页是否为dirty，即是否需要在swap out的时候写回外存；
  * 第5位表示是否被访问；
  * 3-4位恒为0；
  * 0-2位分别表示存在位、是否允许读写、访问该页需要的特权级；
